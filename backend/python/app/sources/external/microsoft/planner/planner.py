

import json
import logging
from dataclasses import asdict
from typing import Any, Dict, List, Mapping, Optional

from kiota_abstractions.base_request_configuration import (  # type: ignore
    RequestConfiguration,
)
from msgraph.generated.planner.buckets.buckets_request_builder import (  # type: ignore
    BucketsRequestBuilder,
)

# Import MS Graph specific query parameter classes for Planner
from msgraph.generated.planner.plans.plans_request_builder import (  # type: ignore
    PlansRequestBuilder,
)
from msgraph.generated.planner.tasks.tasks_request_builder import (  # type: ignore
    TasksRequestBuilder,
)
from msgraph.generated.users.item.planner.planner_request_builder import (  # type: ignore
    PlannerRequestBuilder,
)

from app.sources.client.microsoft.microsoft import MSGraphClient


# Planner-specific response wrapper
class PlannerResponse:
    """Standardized Planner API response wrapper."""
    success: bool
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    message: Optional[str] = None

    def __init__(self, success: bool, data: Optional[Dict[str, Any]] = None, error: Optional[str] = None, message: Optional[str] = None) -> None:
        self.success = success
        self.data = data
        self.error = error
        self.message = message

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    def to_json(self) -> str:
        return json.dumps(self.to_dict())

# Set up logger
logger = logging.getLogger(__name__)

class PlannerDataSource:
    """
    Comprehensive Microsoft Planner API client with complete Plans, Buckets, and Tasks coverage.

    Features:
    - Complete Planner API coverage with 318 methods organized by operation type
    - Support for Personal Planner, User Planner, and Group Planner
    - Complete Plan operations: create, read, update, delete, manage plans
    - Complete Bucket operations: organize tasks into buckets within plans
    - Complete Task operations: create, assign, track, and manage tasks
    - Task Assignment and Progress tracking with detailed status updates
    - Task Board Format support: assigned-to, bucket, and progress views
    - Plan Details and Configuration: categories, descriptions, context
    - Roster Management for plan membership and permissions
    - Checklist support for task sub-items and detailed tracking
    - Search capabilities across plans, buckets, and tasks
    - Delta synchronization for efficient change tracking
    - Microsoft Graph SDK integration with Planner-specific optimizations
    - Async snake_case method names for all operations
    - Standardized PlannerResponse format for all responses
    - Comprehensive error handling and Planner-specific response processing

    EXCLUDED OPERATIONS (modify EXCLUDED_KEYWORDS list to change):
    - OneDrive operations (drive, drives, items)
    - Teams operations (chats, teams, channels)
    - SharePoint operations (sites, lists, document libraries)
    - OneNote operations (notebooks, sections, pages)
    - Outlook operations (messages, events, contacts, calendar, mail folders)
    - Directory operations (directoryObjects, devices)
    - Admin operations (admin, compliance, security)
    - To-Do operations (todo lists and tasks - separate from Planner)
    - Device management operations
    - Communications operations (communications, education, identity)

    Operation Types:
    - Plans operations: Plan management, creation, and configuration
    - Buckets operations: Task organization and bucket management
    - Tasks operations: Task creation, assignment, and tracking
    - Details operations: Plan details, task details, bucket details
    - Assignments operations: Task assignments, checklist items, progress
    - Rosters operations: Plan membership and roster management
    - Board Format operations: Task board views and formatting
    - Favorites operations: Favorite plans, recent plans, shared plans
    - Sync operations: Delta synchronization and change tracking
    - General operations: Base Planner functionality
    """

    def __init__(self, client: MSGraphClient) -> None:
        """Initialize with Microsoft Graph SDK client optimized for Planner."""
        self.client = client.get_client().get_ms_graph_service_client()
        if not hasattr(self.client, "me"):
            raise ValueError("Client must be a Microsoft Graph SDK client")
        logger.info("Planner client initialized with 318 methods")

    def _handle_planner_response(self, response: object) -> PlannerResponse:
        """Handle Planner API response with comprehensive error handling."""
        try:
            if response is None:
                return PlannerResponse(success=False, error="Empty response from Planner API")
            success = True
            error_msg = None

            # Enhanced error response handling for Planner operations
            if hasattr(response, 'error'):
                success = False
                error_msg = str(response.error)
            elif isinstance(response, dict) and 'error' in response:
                success = False
                error_info = response['error']
                if isinstance(error_info, dict):
                    error_code = error_info.get('code', 'Unknown')
                    error_message = error_info.get('message', 'No message')
                    error_msg = f"{error_code}: {error_message}"
                else:
                    error_msg = str(error_info)
            elif hasattr(response, 'code') and hasattr(response, 'message'):
                success = False
                error_msg = f"{response.code}: {response.message}"

            return PlannerResponse(
                success=success,
                data=response,
                error=error_msg,
            )
        except Exception as e:
            logger.error(f"Error handling Planner response: {e}")
            return PlannerResponse(success=False, error=str(e))

    def get_data_source(self) -> 'PlannerDataSource':
        """Get the underlying Planner client."""
        return self

    # ========== PLANS OPERATIONS (272 methods) ==========

    async def groups_delete_planner(
        self,
        group_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property planner for groups.
        Planner operation: DELETE /groups/{group-id}/planner
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_get_planner(
        self,
        group_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get planner from groups.
        Planner operation: GET /groups/{group-id}/planner
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlannerRequestBuilder.PlannerRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlannerRequestBuilder.PlannerRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_update_planner(
        self,
        group_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property planner in groups.
        Planner operation: PATCH /groups/{group-id}/planner
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_create_plans(
        self,
        group_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to plans for groups.
        Planner operation: POST /groups/{group-id}/planner/plans
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_list_plans(
        self,
        group_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """List plans.
        Planner operation: GET /groups/{group-id}/planner/plans
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_delete_plans(
        self,
        group_id: str,
        plannerPlan_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property plans for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_get_plans(
        self,
        group_id: str,
        plannerPlan_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plans from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_update_plans(
        self,
        group_id: str,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property plans in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_create_buckets(
        self,
        group_id: str,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to buckets for groups.
        Planner operation: POST /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_list_buckets(
        self,
        group_id: str,
        plannerPlan_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get buckets from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_delete_buckets(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property buckets for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_get_buckets(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get buckets from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_update_buckets(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property buckets in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_create_tasks(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for groups.
        Planner operation: POST /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_list_tasks(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_delete_tasks(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_get_tasks(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_update_tasks(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_delete_assigned_to_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_get_assigned_to_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_update_assigned_to_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_delete_bucket_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_get_bucket_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_update_bucket_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_delete_details(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_get_details(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_update_details(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_delete_progress_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_get_progress_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_buckets_tasks_update_progress_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_delete_details(
        self,
        group_id: str,
        plannerPlan_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_get_details(
        self,
        group_id: str,
        plannerPlan_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_update_details(
        self,
        group_id: str,
        plannerPlan_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_create_tasks(
        self,
        group_id: str,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for groups.
        Planner operation: POST /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_list_tasks(
        self,
        group_id: str,
        plannerPlan_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_delete_tasks(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_get_tasks(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_update_tasks(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_delete_assigned_to_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_get_assigned_to_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_update_assigned_to_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_delete_bucket_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_get_bucket_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_update_bucket_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_delete_details(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_get_details(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_update_details(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_delete_progress_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for groups.
        Planner operation: DELETE /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_get_progress_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from groups.
        Planner operation: GET /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def groups_planner_plans_tasks_update_progress_task_board_format(
        self,
        group_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in groups.
        Planner operation: PATCH /groups/{group-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            group_id (str, required): Planner group id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.groups.by_group_id(group_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_delete_planner(
        self,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property planner for me.
        Planner operation: DELETE /me/planner
        Operation type: plans
        Args:
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_get_planner(
        self,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get planner from me.
        Planner operation: GET /me/planner
        Operation type: plans
        Args:
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlannerRequestBuilder.PlannerRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlannerRequestBuilder.PlannerRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_update_planner(
        self,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property planner in me.
        Planner operation: PATCH /me/planner
        Operation type: plans
        Args:
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_create_plans(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to plans for me.
        Planner operation: POST /me/planner/plans
        Operation type: plans
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_list_plans(
        self,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """List plans.
        Planner operation: GET /me/planner/plans
        Operation type: plans
        Args:
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_delete_plans(
        self,
        plannerPlan_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property plans for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_get_plans(
        self,
        plannerPlan_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plans from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_update_plans(
        self,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property plans in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_create_buckets(
        self,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to buckets for me.
        Planner operation: POST /me/planner/plans/{plannerPlan-id}/buckets
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_list_buckets(
        self,
        plannerPlan_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get buckets from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/buckets
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_delete_buckets(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property buckets for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_get_buckets(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get buckets from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_update_buckets(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property buckets in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_create_tasks(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for me.
        Planner operation: POST /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_list_tasks(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_delete_tasks(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_get_tasks(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_update_tasks(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_delete_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_get_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_update_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_delete_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_get_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_update_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_delete_details(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_get_details(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_update_details(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_delete_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_get_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_buckets_tasks_update_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_delete_details(
        self,
        plannerPlan_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_get_details(
        self,
        plannerPlan_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_update_details(
        self,
        plannerPlan_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_create_tasks(
        self,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for me.
        Planner operation: POST /me/planner/plans/{plannerPlan-id}/tasks
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_list_tasks(
        self,
        plannerPlan_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/tasks
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_delete_tasks(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_get_tasks(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_update_tasks(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_delete_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_get_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_update_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_delete_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_get_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_update_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_delete_details(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_get_details(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_update_details(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_delete_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for me.
        Planner operation: DELETE /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_get_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from me.
        Planner operation: GET /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_plans_tasks_update_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in me.
        Planner operation: PATCH /me/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_create_tasks(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for me.
        Planner operation: POST /me/planner/tasks
        Operation type: plans
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_list_tasks(
        self,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """List tasks.
        Planner operation: GET /me/planner/tasks
        Operation type: plans
        Args:
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_delete_tasks(
        self,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for me.
        Planner operation: DELETE /me/planner/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_get_tasks(
        self,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from me.
        Planner operation: GET /me/planner/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_update_tasks(
        self,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in me.
        Planner operation: PATCH /me/planner/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_delete_assigned_to_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for me.
        Planner operation: DELETE /me/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_get_assigned_to_task_board_format(
        self,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from me.
        Planner operation: GET /me/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_update_assigned_to_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in me.
        Planner operation: PATCH /me/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_delete_bucket_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for me.
        Planner operation: DELETE /me/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_get_bucket_task_board_format(
        self,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from me.
        Planner operation: GET /me/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_update_bucket_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in me.
        Planner operation: PATCH /me/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_delete_details(
        self,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for me.
        Planner operation: DELETE /me/planner/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_get_details(
        self,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from me.
        Planner operation: GET /me/planner/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_update_details(
        self,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in me.
        Planner operation: PATCH /me/planner/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_delete_progress_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for me.
        Planner operation: DELETE /me/planner/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_get_progress_task_board_format(
        self,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from me.
        Planner operation: GET /me/planner/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def me_planner_tasks_update_progress_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in me.
        Planner operation: PATCH /me/planner/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.planner.tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_planner_get_planner(
        self,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get planner.
        Planner operation: GET /planner
        Operation type: plans
        Args:
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_planner_update_planner(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update planner.
        Planner operation: PATCH /planner
        Operation type: plans
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_create_buckets(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create plannerBucket.
        Planner operation: POST /planner/buckets
        Operation type: plans
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_list_buckets(
        self,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """List buckets.
        Planner operation: GET /planner/buckets
        Operation type: plans
        Args:
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = BucketsRequestBuilder.BucketsRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = BucketsRequestBuilder.BucketsRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_delete_buckets(
        self,
        plannerBucket_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete plannerBucket.
        Planner operation: DELETE /planner/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_get_buckets(
        self,
        plannerBucket_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plannerBucket.
        Planner operation: GET /planner/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = BucketsRequestBuilder.BucketsRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = BucketsRequestBuilder.BucketsRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_update_buckets(
        self,
        plannerBucket_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update plannerbucket.
        Planner operation: PATCH /planner/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_create_tasks(
        self,
        plannerBucket_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for planner.
        Planner operation: POST /planner/buckets/{plannerBucket-id}/tasks
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_list_tasks(
        self,
        plannerBucket_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """List tasks.
        Planner operation: GET /planner/buckets/{plannerBucket-id}/tasks
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = BucketsRequestBuilder.BucketsRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = BucketsRequestBuilder.BucketsRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_delete_tasks(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for planner.
        Planner operation: DELETE /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_get_tasks(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from planner.
        Planner operation: GET /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = BucketsRequestBuilder.BucketsRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = BucketsRequestBuilder.BucketsRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_update_tasks(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in planner.
        Planner operation: PATCH /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_delete_assigned_to_task_board_format(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for planner.
        Planner operation: DELETE /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_get_assigned_to_task_board_format(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from planner.
        Planner operation: GET /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = BucketsRequestBuilder.BucketsRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = BucketsRequestBuilder.BucketsRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_update_assigned_to_task_board_format(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in planner.
        Planner operation: PATCH /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_delete_bucket_task_board_format(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for planner.
        Planner operation: DELETE /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_get_bucket_task_board_format(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from planner.
        Planner operation: GET /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = BucketsRequestBuilder.BucketsRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = BucketsRequestBuilder.BucketsRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_update_bucket_task_board_format(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in planner.
        Planner operation: PATCH /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_delete_details(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for planner.
        Planner operation: DELETE /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_get_details(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from planner.
        Planner operation: GET /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = BucketsRequestBuilder.BucketsRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = BucketsRequestBuilder.BucketsRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_update_details(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in planner.
        Planner operation: PATCH /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_delete_progress_task_board_format(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for planner.
        Planner operation: DELETE /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_get_progress_task_board_format(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from planner.
        Planner operation: GET /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = BucketsRequestBuilder.BucketsRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = BucketsRequestBuilder.BucketsRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_buckets_tasks_update_progress_task_board_format(
        self,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in planner.
        Planner operation: PATCH /planner/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_create_plans(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create plannerPlan.
        Planner operation: POST /planner/plans
        Operation type: plans
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_list_plans(
        self,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """List plans.
        Planner operation: GET /planner/plans
        Operation type: plans
        Args:
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_delete_plans(
        self,
        plannerPlan_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete plannerPlan.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_get_plans(
        self,
        plannerPlan_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plannerPlan.
        Planner operation: GET /planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_update_plans(
        self,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update plannerPlan.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_create_buckets(
        self,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to buckets for planner.
        Planner operation: POST /planner/plans/{plannerPlan-id}/buckets
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_list_buckets(
        self,
        plannerPlan_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """List buckets.
        Planner operation: GET /planner/plans/{plannerPlan-id}/buckets
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_delete_buckets(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property buckets for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_get_buckets(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get buckets from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_update_buckets(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property buckets in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_create_tasks(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for planner.
        Planner operation: POST /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_list_tasks(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_delete_tasks(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_get_tasks(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_update_tasks(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_delete_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_get_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_update_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_delete_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_get_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_update_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_delete_details(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_get_details(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_update_details(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_delete_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_get_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_buckets_tasks_update_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_delete_details(
        self,
        plannerPlan_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_get_details(
        self,
        plannerPlan_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plannerPlanDetails.
        Planner operation: GET /planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_update_details(
        self,
        plannerPlan_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update plannerplandetails.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_create_tasks(
        self,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for planner.
        Planner operation: POST /planner/plans/{plannerPlan-id}/tasks
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_list_tasks(
        self,
        plannerPlan_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """List tasks.
        Planner operation: GET /planner/plans/{plannerPlan-id}/tasks
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_delete_tasks(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_get_tasks(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_update_tasks(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_delete_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_get_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_update_assigned_to_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_delete_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_get_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_update_bucket_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_delete_details(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_get_details(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_update_details(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_delete_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for planner.
        Planner operation: DELETE /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_get_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from planner.
        Planner operation: GET /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_plans_tasks_update_progress_task_board_format(
        self,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in planner.
        Planner operation: PATCH /planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_create_tasks(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create plannerTask.
        Planner operation: POST /planner/tasks
        Operation type: plans
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_list_tasks(
        self,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """List plannerTask objects.
        Planner operation: GET /planner/tasks
        Operation type: plans
        Args:
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_delete_tasks(
        self,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete plannerTask.
        Planner operation: DELETE /planner/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_get_tasks(
        self,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plannerTask.
        Planner operation: GET /planner/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_update_tasks(
        self,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update plannerTask.
        Planner operation: PATCH /planner/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_delete_assigned_to_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for planner.
        Planner operation: DELETE /planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_get_assigned_to_task_board_format(
        self,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plannerAssignedToTaskBoardTaskFormat.
        Planner operation: GET /planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_update_assigned_to_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update plannerAssignedToTaskBoardTaskFormat.
        Planner operation: PATCH /planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_delete_bucket_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for planner.
        Planner operation: DELETE /planner/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_get_bucket_task_board_format(
        self,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plannerBucketTaskBoardTaskFormat.
        Planner operation: GET /planner/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_update_bucket_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update plannerBucketTaskBoardTaskFormat.
        Planner operation: PATCH /planner/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_delete_details(
        self,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for planner.
        Planner operation: DELETE /planner/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_get_details(
        self,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plannerTaskDetails.
        Planner operation: GET /planner/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_update_details(
        self,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update plannertaskdetails.
        Planner operation: PATCH /planner/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_delete_progress_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for planner.
        Planner operation: DELETE /planner/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_get_progress_task_board_format(
        self,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plannerProgressTaskBoardTaskFormat.
        Planner operation: GET /planner/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def planner_tasks_update_progress_task_board_format(
        self,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update plannerProgressTaskBoardTaskFormat.
        Planner operation: PATCH /planner/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.planner.tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_delete_planner(
        self,
        user_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property planner for users.
        Planner operation: DELETE /users/{user-id}/planner
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_get_planner(
        self,
        user_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get planner from users.
        Planner operation: GET /users/{user-id}/planner
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlannerRequestBuilder.PlannerRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlannerRequestBuilder.PlannerRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_update_planner(
        self,
        user_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property planner in users.
        Planner operation: PATCH /users/{user-id}/planner
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_create_plans(
        self,
        user_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to plans for users.
        Planner operation: POST /users/{user-id}/planner/plans
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_list_plans(
        self,
        user_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plans from users.
        Planner operation: GET /users/{user-id}/planner/plans
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_delete_plans(
        self,
        user_id: str,
        plannerPlan_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property plans for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_get_plans(
        self,
        user_id: str,
        plannerPlan_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get plans from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_update_plans(
        self,
        user_id: str,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property plans in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_create_buckets(
        self,
        user_id: str,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to buckets for users.
        Planner operation: POST /users/{user-id}/planner/plans/{plannerPlan-id}/buckets
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_list_buckets(
        self,
        user_id: str,
        plannerPlan_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get buckets from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/buckets
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_delete_buckets(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property buckets for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_get_buckets(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get buckets from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_update_buckets(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property buckets in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_create_tasks(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for users.
        Planner operation: POST /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_list_tasks(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_delete_tasks(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_get_tasks(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_update_tasks(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_delete_assigned_to_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_get_assigned_to_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_update_assigned_to_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_delete_bucket_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_get_bucket_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_update_bucket_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_delete_details(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_get_details(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_update_details(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_delete_progress_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_get_progress_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_buckets_tasks_update_progress_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerBucket_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/buckets/{plannerBucket-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerBucket_id (str, required): Planner plannerBucket id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).buckets.by_planner_bucket_id(plannerBucket_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_delete_details(
        self,
        user_id: str,
        plannerPlan_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_get_details(
        self,
        user_id: str,
        plannerPlan_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_update_details(
        self,
        user_id: str,
        plannerPlan_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_create_tasks(
        self,
        user_id: str,
        plannerPlan_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for users.
        Planner operation: POST /users/{user-id}/planner/plans/{plannerPlan-id}/tasks
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_list_tasks(
        self,
        user_id: str,
        plannerPlan_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/tasks
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_delete_tasks(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_get_tasks(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_update_tasks(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_delete_assigned_to_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_get_assigned_to_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_update_assigned_to_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_delete_bucket_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_get_bucket_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_update_bucket_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_delete_details(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_get_details(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_update_details(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_delete_progress_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for users.
        Planner operation: DELETE /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_get_progress_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from users.
        Planner operation: GET /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = PlansRequestBuilder.PlansRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = PlansRequestBuilder.PlansRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_plans_tasks_update_progress_task_board_format(
        self,
        user_id: str,
        plannerPlan_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in users.
        Planner operation: PATCH /users/{user-id}/planner/plans/{plannerPlan-id}/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerPlan_id (str, required): Planner plannerPlan id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.plans.by_planner_plan_id(plannerPlan_id).tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_create_tasks(
        self,
        user_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to tasks for users.
        Planner operation: POST /users/{user-id}/planner/tasks
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_list_tasks(
        self,
        user_id: str,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from users.
        Planner operation: GET /users/{user-id}/planner/tasks
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_delete_tasks(
        self,
        user_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property tasks for users.
        Planner operation: DELETE /users/{user-id}/planner/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_get_tasks(
        self,
        user_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get tasks from users.
        Planner operation: GET /users/{user-id}/planner/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_update_tasks(
        self,
        user_id: str,
        plannerTask_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property tasks in users.
        Planner operation: PATCH /users/{user-id}/planner/tasks/{plannerTask-id}
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_delete_assigned_to_task_board_format(
        self,
        user_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property assignedToTaskBoardFormat for users.
        Planner operation: DELETE /users/{user-id}/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_get_assigned_to_task_board_format(
        self,
        user_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get assignedToTaskBoardFormat from users.
        Planner operation: GET /users/{user-id}/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_update_assigned_to_task_board_format(
        self,
        user_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property assignedToTaskBoardFormat in users.
        Planner operation: PATCH /users/{user-id}/planner/tasks/{plannerTask-id}/assignedToTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).assigned_to_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_delete_bucket_task_board_format(
        self,
        user_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property bucketTaskBoardFormat for users.
        Planner operation: DELETE /users/{user-id}/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_get_bucket_task_board_format(
        self,
        user_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get bucketTaskBoardFormat from users.
        Planner operation: GET /users/{user-id}/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_update_bucket_task_board_format(
        self,
        user_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property bucketTaskBoardFormat in users.
        Planner operation: PATCH /users/{user-id}/planner/tasks/{plannerTask-id}/bucketTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).bucket_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_delete_details(
        self,
        user_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property details for users.
        Planner operation: DELETE /users/{user-id}/planner/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).details.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_get_details(
        self,
        user_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get details from users.
        Planner operation: GET /users/{user-id}/planner/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).details.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_update_details(
        self,
        user_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property details in users.
        Planner operation: PATCH /users/{user-id}/planner/tasks/{plannerTask-id}/details
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).details.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_delete_progress_task_board_format(
        self,
        user_id: str,
        plannerTask_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property progressTaskBoardFormat for users.
        Planner operation: DELETE /users/{user-id}/planner/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_get_progress_task_board_format(
        self,
        user_id: str,
        plannerTask_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get progressTaskBoardFormat from users.
        Planner operation: GET /users/{user-id}/planner/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = TasksRequestBuilder.TasksRequestBuilderGetQueryParameters()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = TasksRequestBuilder.TasksRequestBuilderGetRequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_planner_tasks_update_progress_task_board_format(
        self,
        user_id: str,
        plannerTask_id: str,
        If_Match: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property progressTaskBoardFormat in users.
        Planner operation: PATCH /users/{user-id}/planner/tasks/{plannerTask-id}/progressTaskBoardFormat
        Operation type: plans
        Args:
            user_id (str, required): Planner user id identifier
            plannerTask_id (str, required): Planner plannerTask id identifier
            If_Match (str, required): ETag value.
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).planner.tasks.by_planner_task_id(plannerTask_id).progress_task_board_format.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    # ========== ASSIGNMENTS OPERATIONS (44 methods) ==========

    async def policies_create_role_management_policy_assignments(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to roleManagementPolicyAssignments for policies.
        Planner operation: POST /policies/roleManagementPolicyAssignments
        Operation type: assignments
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.policies.role_management_policy_assignments.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def policies_list_role_management_policy_assignments(
        self,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """List roleManagementPolicyAssignments.
        Planner operation: GET /policies/roleManagementPolicyAssignments
        Operation type: assignments
        Args:
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.policies.role_management_policy_assignments.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def policies_delete_role_management_policy_assignments(
        self,
        unifiedRoleManagementPolicyAssignment_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property roleManagementPolicyAssignments for policies.
        Planner operation: DELETE /policies/roleManagementPolicyAssignments/{unifiedRoleManagementPolicyAssignment-id}
        Operation type: assignments
        Args:
            unifiedRoleManagementPolicyAssignment_id (str, required): Planner unifiedRoleManagementPolicyAssignment id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.policies.role_management_policy_assignments.by_roleManagementPolicyAssignment_id(unifiedRoleManagementPolicyAssignment_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def policies_get_role_management_policy_assignments(
        self,
        unifiedRoleManagementPolicyAssignment_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get unifiedRoleManagementPolicyAssignment.
        Planner operation: GET /policies/roleManagementPolicyAssignments/{unifiedRoleManagementPolicyAssignment-id}
        Operation type: assignments
        Args:
            unifiedRoleManagementPolicyAssignment_id (str, required): Planner unifiedRoleManagementPolicyAssignment id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.policies.role_management_policy_assignments.by_roleManagementPolicyAssignment_id(unifiedRoleManagementPolicyAssignment_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def policies_update_role_management_policy_assignments(
        self,
        unifiedRoleManagementPolicyAssignment_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property roleManagementPolicyAssignments in policies.
        Planner operation: PATCH /policies/roleManagementPolicyAssignments/{unifiedRoleManagementPolicyAssignment-id}
        Operation type: assignments
        Args:
            unifiedRoleManagementPolicyAssignment_id (str, required): Planner unifiedRoleManagementPolicyAssignment id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.policies.role_management_policy_assignments.by_roleManagementPolicyAssignment_id(unifiedRoleManagementPolicyAssignment_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def policies_role_management_policy_assignments_get_policy(
        self,
        unifiedRoleManagementPolicyAssignment_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get policy from policies.
        Planner operation: GET /policies/roleManagementPolicyAssignments/{unifiedRoleManagementPolicyAssignment-id}/policy
        Operation type: assignments
        Args:
            unifiedRoleManagementPolicyAssignment_id (str, required): Planner unifiedRoleManagementPolicyAssignment id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.policies.role_management_policy_assignments.by_roleManagementPolicyAssignment_id(unifiedRoleManagementPolicyAssignment_id).policy.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_create_role_assignment_schedule_instances(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to roleAssignmentScheduleInstances for roleManagement.
        Planner operation: POST /roleManagement/entitlementManagement/roleAssignmentScheduleInstances
        Operation type: assignments
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_instances.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_list_role_assignment_schedule_instances(
        self,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleAssignmentScheduleInstances from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleInstances
        Operation type: assignments
        Args:
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_instances.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedule_instances_filter_by_current_user(
        self,
        on: str,
        True_: str,
        dollar_select: Optional[List[str]] = None,
        dollar_orderby: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Invoke function filterByCurrentUser.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleInstances/filterByCurrentUser(on='{on}')
        Operation type: assignments
        Args:
            on (str, required): Planner path parameter: on
            True_ (str, required): Usage: on='{on}'
            dollar_select (List[str], optional): Select properties to be returned
            dollar_orderby (List[str], optional): Order items by property values
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_instances.filter_by_current_user(on='{on}').get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_delete_role_assignment_schedule_instances(
        self,
        unifiedRoleAssignmentScheduleInstance_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property roleAssignmentScheduleInstances for roleManagement.
        Planner operation: DELETE /roleManagement/entitlementManagement/roleAssignmentScheduleInstances/{unifiedRoleAssignmentScheduleInstance-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleInstance_id (str, required): Planner unifiedRoleAssignmentScheduleInstance id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_instances.by_roleAssignmentScheduleInstance_id(unifiedRoleAssignmentScheduleInstance_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_get_role_assignment_schedule_instances(
        self,
        unifiedRoleAssignmentScheduleInstance_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleAssignmentScheduleInstances from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleInstances/{unifiedRoleAssignmentScheduleInstance-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleInstance_id (str, required): Planner unifiedRoleAssignmentScheduleInstance id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_instances.by_roleAssignmentScheduleInstance_id(unifiedRoleAssignmentScheduleInstance_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_update_role_assignment_schedule_instances(
        self,
        unifiedRoleAssignmentScheduleInstance_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property roleAssignmentScheduleInstances in roleManagement.
        Planner operation: PATCH /roleManagement/entitlementManagement/roleAssignmentScheduleInstances/{unifiedRoleAssignmentScheduleInstance-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleInstance_id (str, required): Planner unifiedRoleAssignmentScheduleInstance id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_instances.by_roleAssignmentScheduleInstance_id(unifiedRoleAssignmentScheduleInstance_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedule_instances_get_app_scope(
        self,
        unifiedRoleAssignmentScheduleInstance_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get appScope from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleInstances/{unifiedRoleAssignmentScheduleInstance-id}/appScope
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleInstance_id (str, required): Planner unifiedRoleAssignmentScheduleInstance id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_instances.by_roleAssignmentScheduleInstance_id(unifiedRoleAssignmentScheduleInstance_id).app_scope.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedule_instances_get_principal(
        self,
        unifiedRoleAssignmentScheduleInstance_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get principal from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleInstances/{unifiedRoleAssignmentScheduleInstance-id}/principal
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleInstance_id (str, required): Planner unifiedRoleAssignmentScheduleInstance id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_instances.by_roleAssignmentScheduleInstance_id(unifiedRoleAssignmentScheduleInstance_id).principal.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedule_instances_get_role_definition(
        self,
        unifiedRoleAssignmentScheduleInstance_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleDefinition from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleInstances/{unifiedRoleAssignmentScheduleInstance-id}/roleDefinition
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleInstance_id (str, required): Planner unifiedRoleAssignmentScheduleInstance id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_instances.by_roleAssignmentScheduleInstance_id(unifiedRoleAssignmentScheduleInstance_id).role_definition.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_create_role_assignment_schedule_requests(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to roleAssignmentScheduleRequests for roleManagement.
        Planner operation: POST /roleManagement/entitlementManagement/roleAssignmentScheduleRequests
        Operation type: assignments
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_list_role_assignment_schedule_requests(
        self,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleAssignmentScheduleRequests from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleRequests
        Operation type: assignments
        Args:
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedule_requests_filter_by_current_user(
        self,
        on: str,
        True_: str,
        dollar_select: Optional[List[str]] = None,
        dollar_orderby: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Invoke function filterByCurrentUser.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleRequests/filterByCurrentUser(on='{on}')
        Operation type: assignments
        Args:
            on (str, required): Planner path parameter: on
            True_ (str, required): Usage: on='{on}'
            dollar_select (List[str], optional): Select properties to be returned
            dollar_orderby (List[str], optional): Order items by property values
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.filter_by_current_user(on='{on}').get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_delete_role_assignment_schedule_requests(
        self,
        unifiedRoleAssignmentScheduleRequest_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property roleAssignmentScheduleRequests for roleManagement.
        Planner operation: DELETE /roleManagement/entitlementManagement/roleAssignmentScheduleRequests/{unifiedRoleAssignmentScheduleRequest-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleRequest_id (str, required): Planner unifiedRoleAssignmentScheduleRequest id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.by_roleAssignmentScheduleRequest_id(unifiedRoleAssignmentScheduleRequest_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_get_role_assignment_schedule_requests(
        self,
        unifiedRoleAssignmentScheduleRequest_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleAssignmentScheduleRequests from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleRequests/{unifiedRoleAssignmentScheduleRequest-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleRequest_id (str, required): Planner unifiedRoleAssignmentScheduleRequest id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.by_roleAssignmentScheduleRequest_id(unifiedRoleAssignmentScheduleRequest_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_update_role_assignment_schedule_requests(
        self,
        unifiedRoleAssignmentScheduleRequest_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property roleAssignmentScheduleRequests in roleManagement.
        Planner operation: PATCH /roleManagement/entitlementManagement/roleAssignmentScheduleRequests/{unifiedRoleAssignmentScheduleRequest-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleRequest_id (str, required): Planner unifiedRoleAssignmentScheduleRequest id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.by_roleAssignmentScheduleRequest_id(unifiedRoleAssignmentScheduleRequest_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedule_requests_get_app_scope(
        self,
        unifiedRoleAssignmentScheduleRequest_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get appScope from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleRequests/{unifiedRoleAssignmentScheduleRequest-id}/appScope
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleRequest_id (str, required): Planner unifiedRoleAssignmentScheduleRequest id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.by_roleAssignmentScheduleRequest_id(unifiedRoleAssignmentScheduleRequest_id).app_scope.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedule_requests_unified_role_assignment_schedule_request_cancel(
        self,
        unifiedRoleAssignmentScheduleRequest_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Invoke action cancel.
        Planner operation: POST /roleManagement/entitlementManagement/roleAssignmentScheduleRequests/{unifiedRoleAssignmentScheduleRequest-id}/cancel
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleRequest_id (str, required): Planner unifiedRoleAssignmentScheduleRequest id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.by_roleAssignmentScheduleRequest_id(unifiedRoleAssignmentScheduleRequest_id).cancel.post(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedule_requests_get_principal(
        self,
        unifiedRoleAssignmentScheduleRequest_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get principal from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleRequests/{unifiedRoleAssignmentScheduleRequest-id}/principal
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleRequest_id (str, required): Planner unifiedRoleAssignmentScheduleRequest id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.by_roleAssignmentScheduleRequest_id(unifiedRoleAssignmentScheduleRequest_id).principal.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedule_requests_get_role_definition(
        self,
        unifiedRoleAssignmentScheduleRequest_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleDefinition from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleRequests/{unifiedRoleAssignmentScheduleRequest-id}/roleDefinition
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleRequest_id (str, required): Planner unifiedRoleAssignmentScheduleRequest id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.by_roleAssignmentScheduleRequest_id(unifiedRoleAssignmentScheduleRequest_id).role_definition.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedule_requests_get_target_schedule(
        self,
        unifiedRoleAssignmentScheduleRequest_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get targetSchedule from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentScheduleRequests/{unifiedRoleAssignmentScheduleRequest-id}/targetSchedule
        Operation type: assignments
        Args:
            unifiedRoleAssignmentScheduleRequest_id (str, required): Planner unifiedRoleAssignmentScheduleRequest id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedule_requests.by_roleAssignmentScheduleRequest_id(unifiedRoleAssignmentScheduleRequest_id).target_schedule.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_create_role_assignment_schedules(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create new navigation property to roleAssignmentSchedules for roleManagement.
        Planner operation: POST /roleManagement/entitlementManagement/roleAssignmentSchedules
        Operation type: assignments
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedules.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_list_role_assignment_schedules(
        self,
        dollar_orderby: Optional[List[str]] = None,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleAssignmentSchedules from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentSchedules
        Operation type: assignments
        Args:
            dollar_orderby (List[str], optional): Order items by property values
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedules.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedules_filter_by_current_user(
        self,
        on: str,
        True_: str,
        dollar_select: Optional[List[str]] = None,
        dollar_orderby: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Invoke function filterByCurrentUser.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentSchedules/filterByCurrentUser(on='{on}')
        Operation type: assignments
        Args:
            on (str, required): Planner path parameter: on
            True_ (str, required): Usage: on='{on}'
            dollar_select (List[str], optional): Select properties to be returned
            dollar_orderby (List[str], optional): Order items by property values
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedules.filter_by_current_user(on='{on}').get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_delete_role_assignment_schedules(
        self,
        unifiedRoleAssignmentSchedule_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property roleAssignmentSchedules for roleManagement.
        Planner operation: DELETE /roleManagement/entitlementManagement/roleAssignmentSchedules/{unifiedRoleAssignmentSchedule-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignmentSchedule_id (str, required): Planner unifiedRoleAssignmentSchedule id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedules.by_roleAssignmentSchedule_id(unifiedRoleAssignmentSchedule_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_get_role_assignment_schedules(
        self,
        unifiedRoleAssignmentSchedule_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleAssignmentSchedules from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentSchedules/{unifiedRoleAssignmentSchedule-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignmentSchedule_id (str, required): Planner unifiedRoleAssignmentSchedule id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedules.by_roleAssignmentSchedule_id(unifiedRoleAssignmentSchedule_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_update_role_assignment_schedules(
        self,
        unifiedRoleAssignmentSchedule_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property roleAssignmentSchedules in roleManagement.
        Planner operation: PATCH /roleManagement/entitlementManagement/roleAssignmentSchedules/{unifiedRoleAssignmentSchedule-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignmentSchedule_id (str, required): Planner unifiedRoleAssignmentSchedule id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedules.by_roleAssignmentSchedule_id(unifiedRoleAssignmentSchedule_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedules_get_app_scope(
        self,
        unifiedRoleAssignmentSchedule_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get appScope from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentSchedules/{unifiedRoleAssignmentSchedule-id}/appScope
        Operation type: assignments
        Args:
            unifiedRoleAssignmentSchedule_id (str, required): Planner unifiedRoleAssignmentSchedule id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedules.by_roleAssignmentSchedule_id(unifiedRoleAssignmentSchedule_id).app_scope.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedules_get_principal(
        self,
        unifiedRoleAssignmentSchedule_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get principal from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentSchedules/{unifiedRoleAssignmentSchedule-id}/principal
        Operation type: assignments
        Args:
            unifiedRoleAssignmentSchedule_id (str, required): Planner unifiedRoleAssignmentSchedule id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedules.by_roleAssignmentSchedule_id(unifiedRoleAssignmentSchedule_id).principal.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignment_schedules_get_role_definition(
        self,
        unifiedRoleAssignmentSchedule_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleDefinition from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignmentSchedules/{unifiedRoleAssignmentSchedule-id}/roleDefinition
        Operation type: assignments
        Args:
            unifiedRoleAssignmentSchedule_id (str, required): Planner unifiedRoleAssignmentSchedule id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignment_schedules.by_roleAssignmentSchedule_id(unifiedRoleAssignmentSchedule_id).role_definition.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_create_role_assignments(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Create unifiedRoleAssignment.
        Planner operation: POST /roleManagement/entitlementManagement/roleAssignments
        Operation type: assignments
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignments.post(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_delete_role_assignments(
        self,
        unifiedRoleAssignment_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property roleAssignments for roleManagement.
        Planner operation: DELETE /roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignment_id (str, required): Planner unifiedRoleAssignment id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignments.by_roleAssignment_id(unifiedRoleAssignment_id).delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_get_role_assignments(
        self,
        unifiedRoleAssignment_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleAssignments from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignment_id (str, required): Planner unifiedRoleAssignment id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignments.by_roleAssignment_id(unifiedRoleAssignment_id).get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_update_role_assignments(
        self,
        unifiedRoleAssignment_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property roleAssignments in roleManagement.
        Planner operation: PATCH /roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}
        Operation type: assignments
        Args:
            unifiedRoleAssignment_id (str, required): Planner unifiedRoleAssignment id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignments.by_roleAssignment_id(unifiedRoleAssignment_id).patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignments_delete_app_scope(
        self,
        unifiedRoleAssignment_id: str,
        If_Match: Optional[str] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Delete navigation property appScope for roleManagement.
        Planner operation: DELETE /roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/appScope
        Operation type: assignments
        Args:
            unifiedRoleAssignment_id (str, required): Planner unifiedRoleAssignment id identifier
            If_Match (str, optional): ETag
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignments.by_roleAssignment_id(unifiedRoleAssignment_id).app_scope.delete(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignments_get_app_scope(
        self,
        unifiedRoleAssignment_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get appScope from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/appScope
        Operation type: assignments
        Args:
            unifiedRoleAssignment_id (str, required): Planner unifiedRoleAssignment id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignments.by_roleAssignment_id(unifiedRoleAssignment_id).app_scope.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignments_update_app_scope(
        self,
        unifiedRoleAssignment_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        request_body: Optional[Mapping[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Update the navigation property appScope in roleManagement.
        Planner operation: PATCH /roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/appScope
        Operation type: assignments
        Args:
            unifiedRoleAssignment_id (str, required): Planner unifiedRoleAssignment id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            request_body (optional): Request body data for Planner operations
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignments.by_roleAssignment_id(unifiedRoleAssignment_id).app_scope.patch(body=request_body, request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignments_get_principal(
        self,
        unifiedRoleAssignment_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get principal from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/principal
        Operation type: assignments
        Args:
            unifiedRoleAssignment_id (str, required): Planner unifiedRoleAssignment id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignments.by_roleAssignment_id(unifiedRoleAssignment_id).principal.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def role_management_entitlement_management_role_assignments_get_role_definition(
        self,
        unifiedRoleAssignment_id: str,
        dollar_select: Optional[List[str]] = None,
        dollar_expand: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Get roleDefinition from roleManagement.
        Planner operation: GET /roleManagement/entitlementManagement/roleAssignments/{unifiedRoleAssignment-id}/roleDefinition
        Operation type: assignments
        Args:
            unifiedRoleAssignment_id (str, required): Planner unifiedRoleAssignment id identifier
            dollar_select (List[str], optional): Select properties to be returned
            dollar_expand (List[str], optional): Expand related entities
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.role_management.entitlement_management.role_assignments.by_roleAssignment_id(unifiedRoleAssignment_id).role_definition.get(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    # ========== GENERAL OPERATIONS (2 methods) ==========

    async def me_reprocess_license_assignment(
        self,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Invoke action reprocessLicenseAssignment.
        Planner operation: POST /me/reprocessLicenseAssignment
        Operation type: general
        Args:
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.me.reprocess_license_assignment.post(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

    async def users_user_reprocess_license_assignment(
        self,
        user_id: str,
        select: Optional[List[str]] = None,
        expand: Optional[List[str]] = None,
        filter: Optional[str] = None,
        orderby: Optional[str] = None,
        search: Optional[str] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> PlannerResponse:
        """Invoke action reprocessLicenseAssignment.
        Planner operation: POST /users/{user-id}/reprocessLicenseAssignment
        Operation type: general
        Args:
            user_id (str, required): Planner user id identifier
            select (optional): Select specific properties to return
            expand (optional): Expand related entities (e.g., details, assignments, buckets)
            filter (optional): Filter the results using OData syntax
            orderby (optional): Order the results by specified properties
            search (optional): Search for plans, buckets, or tasks by content
            top (optional): Limit number of results returned
            skip (optional): Skip number of results for pagination
            headers (optional): Additional headers for the request
            **kwargs: Additional query parameters
        Returns:
            PlannerResponse: Planner response wrapper with success/data/error
        """
        # Build query parameters including OData for Planner
        try:
            # Use typed query parameters
            query_params = RequestConfiguration()

            # Set query parameters using typed object properties
            if select:
                query_params.select = select if isinstance(select, list) else [select]
            if expand:
                query_params.expand = expand if isinstance(expand, list) else [expand]
            if filter:
                query_params.filter = filter
            if orderby:
                query_params.orderby = orderby
            if search:
                query_params.search = search
            if top is not None:
                query_params.top = top
            if skip is not None:
                query_params.skip = skip

            # Create proper typed request configuration
            config = RequestConfiguration()
            config.query_parameters = query_params

            if headers:
                config.headers = headers

            # Add consistency level for search operations in Planner
            if search:
                if not config.headers:
                    config.headers = {}
                config.headers['ConsistencyLevel'] = 'eventual'

            response = await self.client.users.by_user_id(user_id).reprocess_license_assignment.post(request_configuration=config)
            return self._handle_planner_response(response)
        except Exception as e:
            return PlannerResponse(
                success=False,
                error=f"Planner API call failed: {str(e)}",
            )

